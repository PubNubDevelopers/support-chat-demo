{"version":3,"sources":["core/endpoints/publish.js"],"names":["prepareMessagePayload","modules","messagePayload","crypto","config","stringifiedPayload","JSON","stringify","cipherKey","encrypt","getOperation","operationConstants","PNPublishOperation","validateParams","incomingParams","message","channel","subscribeKey","usePost","sendByPost","getURL","publishKey","utils","encodeString","postURL","getRequestTimeout","getTransactionTimeout","isAuthSupported","postPayload","prepareParams","meta","replicate","storeInHistory","ttl","params","store","norep","handleResponse","serverResponse","timetoken"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport { PublishResponse, PublishArguments, ModulesInject } from '../flow_interfaces';\nimport operationConstants from '../constants/operations';\nimport utils from '../utils';\n\nfunction prepareMessagePayload(modules, messagePayload) {\n  const { crypto, config } = modules;\n  let stringifiedPayload = JSON.stringify(messagePayload);\n\n  if (config.cipherKey) {\n    stringifiedPayload = crypto.encrypt(stringifiedPayload);\n    stringifiedPayload = JSON.stringify(stringifiedPayload);\n  }\n\n  return stringifiedPayload;\n}\n\nexport function getOperation(): string {\n  return operationConstants.PNPublishOperation;\n}\n\nexport function validateParams({ config }: ModulesInject, incomingParams: PublishArguments) {\n  let { message, channel } = incomingParams;\n\n  if (!channel) return 'Missing Channel';\n  if (!message) return 'Missing Message';\n  if (!config.subscribeKey) return 'Missing Subscribe Key';\n}\n\nexport function usePost(modules: ModulesInject, incomingParams: PublishArguments) {\n  let { sendByPost = false } = incomingParams;\n  return sendByPost;\n}\n\nexport function getURL(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { config } = modules;\n  const { channel, message } = incomingParams;\n  let stringifiedPayload = prepareMessagePayload(modules, message);\n  return `/publish/${config.publishKey}/${config.subscribeKey}/0/${utils.encodeString(channel)}/0/${utils.encodeString(stringifiedPayload)}`;\n}\n\nexport function postURL(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { config } = modules;\n  const { channel } = incomingParams;\n  return `/publish/${config.publishKey}/${config.subscribeKey}/0/${utils.encodeString(channel)}/0`;\n}\n\nexport function getRequestTimeout({ config }: ModulesInject) {\n  return config.getTransactionTimeout();\n}\n\nexport function isAuthSupported() {\n  return true;\n}\n\nexport function postPayload(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { message } = incomingParams;\n  return prepareMessagePayload(modules, message);\n}\n\nexport function prepareParams(modules: ModulesInject, incomingParams: PublishArguments): Object {\n  const { meta, replicate = true, storeInHistory, ttl } = incomingParams;\n  const params = {};\n\n  if (storeInHistory != null) {\n    if (storeInHistory) {\n      params.store = '1';\n    } else {\n      params.store = '0';\n    }\n  }\n\n  if (ttl) {\n    params.ttl = ttl;\n  }\n\n  if (replicate === false) {\n    params.norep = 'true';\n  }\n\n  if (meta && typeof meta === 'object') {\n    params.meta = JSON.stringify(meta);\n  }\n\n  return params;\n}\n\nexport function handleResponse(modules: ModulesInject, serverResponse: Object): PublishResponse {\n  return { timetoken: serverResponse[2] };\n}\n"],"file":"publish.js"}